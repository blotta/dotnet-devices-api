# Devices API

A RESTful API for managing device resources.

# Features
- Create, update, fetch, delete devices
- Filter devices by brand and state
- Domain-driven validation rules
- PostgreSQL persistence
- Dockerized setup for local and production usage
- OpenAPI specification and Scalar UI
- Unit tests for domain and application layers
- Clean separation of concerns (Domain, Application, Infrastructure, API)

# Tech Stack
- .NET 10
- ASP.NET Core Web API
- Entity Framework Core
- PostgreSQL
- Docker & Docke Compose
- xUnit,Moq, FluetAssertions
- OpenAPI / Scalar

# Design Principles
- Clean Architecture
- Dependency inversion
- Domain-driven validation
- Testable application layer
- Container-first deployment

# Architecture

```txt
API -> Application -> Domain
API -> Infrastructure -> Domain + Application
```

## Domain
- Entities and business rules

## Application
- Use cases, DTOs, interfaces

## Infrastructure
- EF Core repositories & database

## API
- HTTP endpoints

# System Requirements

## Option 1 - Using Docker
- Docker & Docker Compose

## Option 2 - Local Development
- .NET SDK 10
- PostgreSQL 18.1


# Domain Rules
- `CreatedAt` is generated by the database and immutable
- Name and brand cannot be changed when device is `inUse`
- Devices in `inUse` state cannot be deleted


# Running with Docker

Start the entire stack
```sh
docker compose -f .\docker-compose.yml -f .\docker-compose.override.yml up
```
Services:
- API: https://localhost:8081
- PostgreSQL (Not exposed)


# Running Locally (without Docker)

1. Configure connection string in `API/appsettings.development.json`

```json
{
  "ConnectionStrings": {
    "Database": "Host=localhost;Port=5432;Database=devices;Username=dev;Password=dev"
  }
}
```

2. Run API

In the `API` directory, execute:
```sh
dotnet run
```

# API Documentation

In development, the API exposes the following OpenAPI endpoint:

https://localhost:8081/openapi/v1.json

This can be imported into Postman or other API client of your choosing which supports OpenAPI

For convenience, the API also exposes API UI documentation via Scalar:

https://localhost:8081/scalar/


# API Endpoints

## Create a device
```http
POST /api/devices
```
```json
{
  "name": "Device 1",
  "brand": "Cisco"
}
```

## Get device by id
```http
GET /api/devices/{id}
```

## Get all devices (with filters)
```http
GET /api/devices?brand=Cisco&state=available
```
Query params:
- brand: string (optional)
- state: `available`, `inUse`, `inactive` (optional)

## Update device (partial)
```http
PATCH /api/devices/{id}
```
```json
{
  "name": "Device 1",
  "state": "available"
}
```

## Delete device
```http
DELETE /api/devices/{id}
```
# Testing

To run all tests:
```sh
dotnet test --solution Devices.slnx
```

Test projects available:
- `test/Domain.Tests`
  - Device entity
- `test/Application.Tests`
  - DeviceService

# Database

Uses PostgreSQL with EF Core migrations.

Tables:
- `devices`

Indexes:
- `devices.brand`
- `devices.state`

## Connecting to PostgreSQL container via CLI

```sh
docker exec -it db psql -U dev -d devices
```

## Migrations

Ensure the `dotnet-ef` tool is installed:

```sh
dotnet tool install --global dotnet-ef
```

Add a migration:

```sh
dotnet ef migrations add <MigrationName> -p .\Infrastructure\Infrastructure.csproj -s .\API\API.csproj -o .\Persistence\Migrations
```

Updating the database:

Migrations are run automatically when the API project starts

> WARNING: this is not specific to the Development environment. Any other environment, such as Production, is also affected.

# Potential Improvements

- Pagination & sorting for device listing
- Better logging configuration (e.g Serilog)
- Integration tests
- Uncommited connection credentials, even for development environment

# Troubleshooting

## Windows Smart App Control blocks tests

Some Windows installations block dynamically generated test runners.

A temporary fix is to disable Smart App Control:
```txt
Windows Security -> App & Browser control -> Smart App Control settings -> set to "off"
```
## API starts before database

Handled via Docker healthcheck in `docker-compose.yml`

If running manually, ensure PostgreSQL is accepting connections before starting the API.
